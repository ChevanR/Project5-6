vars: {
  d2-config: {
    layout-engine: elk # change = elk
    dark-theme-id: 1
  }
}

classes: {
  start: {
    shape: oval
    style: {
      fill: "#83a06a"
    }
  }
  end: {
    shape: oval
    style: {
      fill: "#a04b6e"
    }
  }
}

title: Unity software diagram {
  shape: text
  near: top-center
  style: {
    font-size: 80
    italic: true {style.stroke: green}
  }
}
stuff: "" {
  grid-rows: 1
  Class-diagram: UML class Diagram {
    grid-rows: 1
    PlayerMovement: PlayerMovement (PlayerMovement.cs) {
      shape: class
      +walkSpeed: float
      +runSpeed: float
      +jumpForce: float
      -currentSpeed: float
      +cameraTransform: Transform
      -rb: Rigidbody
      -isGrounded: bool
      +groundMask: LayerMask
      +groundCheckDistance: float
      -Start()
      -Update()
      -MovePlayer()
      -Jump()
      -CheckIfGrounded()
    }

    ViewSwitch: ViewSwitch (ViewSwitch.cs) {
      shape: class

      +firstPersonPosition: Transform
      +thirdPersonPosition: Transform
      +mainCamera: Transform
      +switchKey: KeyCode
      -isFirstPerson: bool

      -Start()
      -Update()
      -SwitchToFirstPerson()
      -SwitchToThirdPerson()
      -moveCamera(targetPosition\: Transform): IEnumerator
    }
  }
  flowchart: Script flowcharts {
    grid-rows: 1
    playermv: PlayerMovement (PlayerMovement.cs) {
      grid-rows: 2
      update: {
        start -> movePlayer
        movePlayer -> checkJump
        checkJump -> jump: true {style.stroke: green}
        jump -> checkGrounded -> end
        checkJump -> checkGrounded: false {style.stroke: red}

        start: Update() {class: start}
        movePlayer: "MovePlayer()"
        checkJump: "Input.GetKeyDown(KeyCode.Space) AND isGrounded" {shape: diamond}
        jump: "Jump()"
        checkGrounded: "CheckIfGrounded()"
        end: return {class: end}
      }

      movePlayer: {
        start -> checkRun
        checkRun -> setRunSpeed: true {style.stroke: green}
        setRunSpeed -> getInput
        checkRun -> setWalkSpeed: false {style.stroke: red}
        setWalkSpeed -> getInput
        getInput -> end

        start: MovePlayer() {class: start}
        checkRun: Is Right or Left Shift pressed? {shape: diamond}
        setRunSpeed: "currentSpeed = runSpeed"
        setWalkSpeed: "currentSpeed = walkSpeed"
        getInput: "Based on currentSpeed and looking direction, translate the transform to the new position"
        end: return {class: end}
      }

      start: {
        start: Start() {class: start}
        start -> Rigidbody
        Rigidbody -> end

        Rigidbody: set rb to the rigidbody of this script's parent
        end: return {class: end}
      }

      jump: {
        start -> applyJumpForce
        applyJumpForce -> end

        start: Jump() {class: start}
        applyJumpForce: "Apply upward force on rb (rigidbody) for jumping"
        end: return {class: end}
      }
      checkIfGrounded: {
        start -> performRaycast
        performRaycast -> end

        start: CheckIfGrounded() {class: start}
        performRaycast: "Use the groundMask, groundCheckDistance and the transform position to determine the boolean for isGrounded"
        end: return {class: end}
      }
    }

    viewsw: ViewSwitch (ViewSwitch.cs) {
      grid-rows: 2
      start: {
        start: Start() {class: start}
        start -> switchToThirdPerson
        switchToThirdPerson -> end

        switchToThirdPerson: SwitchToThirdPerson()
        end: return {class: end}
      }

      switchToFirstPerson: {
        start -> setFlag
        setFlag -> stopCoroutines
        stopCoroutines -> startCoroutine
        startCoroutine -> end

        start: switchToFirstPerson() {class: start}
        setFlag: "isFirstPerson = true" {class: process}
        stopCoroutines: "StopAllCoroutines()" {class: process}
        startCoroutine: "StartCoroutine(MoveCamera(firstPersonPosition))" {class: process}
        end: return {class: end}
      }
      switchToThirdPerson: {
        start -> setFlag
        setFlag -> stopCoroutines
        stopCoroutines -> startCoroutine
        startCoroutine -> end

        start: switchToThirdPerson() {class: start}
        setFlag: "isFirstPerson = false" {class: process}
        stopCoroutines: "StopAllCoroutines()" {class: process}
        startCoroutine: "StartCoroutine(MoveCamera(thirdPersonPosition))" {class: process}
        end: return {class: end}
      }

      update: {
        update: Update() {class: start}
        update -> InputKey
        InputKey -> checkFirstPerson: true {style.stroke: green}
        InputKey -> end: false {style.stroke: red}
        checkFirstPerson -> ThirdPerson: true {style.stroke: green}
        checkFirstPerson -> FirstPerson: false {style.stroke: red}
        ThirdPerson -> end
        FirstPerson -> end

        InputKey: Input.GetKeyDown(switchKey) {shape: diamond}
        checkFirstPerson: isFirstPerson {shape: diamond}
        ThirdPerson: SwitchToThirdPerson()
        FirstPerson: SwitchToFirstPerson()
        end: return {class: end}
      }

      moveCamera: {
        start -> initialize
        initialize -> loopCheck
        loopCheck -> updatePosition: true {style.stroke: green}
        updatePosition -> incrementTime
        incrementTime -> yield -> loopCheck
        loopCheck -> setFinalPosition: false {style.stroke: red}
        setFinalPosition -> end

        start: moveCamera(targetPosition: Transform) {class: start}
        initialize: "Initialize Variables"
        loopCheck: "elapsedTime < transitionTime?" {shape: diamond}
        updatePosition: "Update Camera Position and Rotation"
        incrementTime: "elapsedTime += Time.deltaTime"
        yield: "wait until next frame"
        setFinalPosition: "Set Final Position and Rotation"
        end: return {class: end}
      }
    }
  }
}
